package pgd

import (
	"bytes"
	"errors"
	"fmt"
	"strings"

	"github.com/dave/jennifer/jen"
	pgs "github.com/lyft/protoc-gen-star/v2"
	pgsgo "github.com/lyft/protoc-gen-star/v2/lang/go"

	dynamopb "github.com/pquerna/protoc-gen-dynamo/dynamo/v1"
)

const (
	moduleName    = "dynamo"
	version       = "0.1.0"
	commentFormat = `// Code generated by protoc-gen-%s v%s. DO NOT EDIT.
// source: %s
`
	shardMinLimit = 2
	shardMaxLimit = 128
)

type Module struct {
	*pgs.ModuleBase
	ctx pgsgo.Context
}

var _ pgs.Module = (*Module)(nil)

func New() pgs.Module {
	return &Module{ModuleBase: &pgs.ModuleBase{}}
}

func (m *Module) InitContext(ctx pgs.BuildContext) {
	m.ModuleBase.InitContext(ctx)
	m.ctx = pgsgo.InitContext(ctx.Parameters())
}

func (m *Module) Name() string {
	return moduleName
}

func (m *Module) Execute(targets map[string]pgs.File, pkgs map[string]pgs.Package) []pgs.Artifact {
	for _, f := range targets {
		msgs := f.AllMessages()
		if n := len(msgs); n == 0 {
			m.Debugf("No messagess in %v, skipping", f.Name())
			continue
		}
		m.processFile(f)
	}
	return m.Artifacts()
}

func (m *Module) processFile(f pgs.File) {
	out := bytes.Buffer{}
	err := m.applyTemplate(&out, f)
	if err != nil {
		m.Logf("couldn't apply template: %s", err)
		m.Fail("code generation failed")
	} else {
		generatedFileName := m.ctx.OutputPath(f).SetExt(fmt.Sprintf(".%s.go", moduleName)).String()
		m.AddGeneratorFile(generatedFileName, out.String())
	}
}

const (
	dynamoV2Pkg  = "github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
	protoPkg     = "google.golang.org/protobuf/proto"
	awsPkg       = "github.com/aws/aws-sdk-go-v2/aws"
	strconvPkg   = "strconv"
	stringsPkg   = "strings"
	fmtPkg       = "fmt"
	timePkg      = "time"
	protozstdPkg = "github.com/pquerna/protoc-gen-dynamo/pkg/protozstd"
	xxhashPkg    = "github.com/cespare/xxhash/v2"

	timestampType = "google.protobuf.Timestamp"
)

// isShardingEnabled checks if sharding is enabled for a key
func isShardingEnabled(key *dynamopb.Key) bool {
	return key != nil && key.Shard != nil && key.Shard.Enabled && key.Shard.ShardCount > 0
}

// validateShardConfig validates that sharding configuration is correct
func validateShardConfig(msg pgs.Message, key *dynamopb.Key) error {
	// If sharding config exists and enabled is true, validate shard_count
	if key == nil || key.Shard == nil || !key.Shard.Enabled {
		return nil
	}

	// Validate shard_count is reasonable (> shardMinLimit and <= shardMinLimit)
	if key.Shard.ShardCount < shardMinLimit {
		return fmt.Errorf("shard_count must be >= %d for message %s (got %d)", shardMinLimit, msg.FullyQualifiedName(), key.Shard.ShardCount)
	}
	if key.Shard.ShardCount > shardMaxLimit {
		return fmt.Errorf("shard_count must be <= %d for message %s (got %d)", shardMaxLimit, msg.FullyQualifiedName(), key.Shard.ShardCount)
	}

	// For sharded keys, validate that sort key is properly configured
	if len(key.SkFields) == 0 && key.SkConst == "" {
		return fmt.Errorf("sharded key must have sort key configured (either sk_fields or sk_const) for message %s", msg.FullyQualifiedName())
	}

	return nil
}

func (m *Module) applyTemplate(buf *bytes.Buffer, in pgs.File) error {
	pkgName := m.ctx.PackageName(in).String()
	importPath := m.ctx.ImportPath(in).String()
	protoFileName := in.Name().String()

	f := jen.NewFilePathName(importPath, pkgName)
	f.HeaderComment(fmt.Sprintf(commentFormat, moduleName, version, protoFileName))

	f.ImportName(dynamoV2Pkg, "types")
	f.ImportName(awsPkg, "aws")
	f.ImportName(protoPkg, "proto")
	f.ImportName(strconvPkg, "strconv")
	f.ImportName(fmtPkg, "fmt")
	f.ImportName(stringsPkg, "strings")
	f.ImportName(timePkg, "time")
	f.ImportName(protozstdPkg, "protozstd")
	f.ImportName(xxhashPkg, "xxhash")

	err := m.applyMarshal(f, in)
	if err != nil {
		return err
	}

	err = m.applyUnmarshal(f, in)
	if err != nil {
		return err
	}

	err = m.applyKeyFuncs(f, in)
	if err != nil {
		return err
	}

	err = m.applyUtilityFuncs(f, in)
	if err != nil {
		return err
	}

	return f.Render(buf)
}

type avType string

const (
	avt_bytes      avType = "B"
	avt_bool       avType = "BOOL"
	avt_byte_set   avType = "BS"
	avt_list       avType = "L"
	avt_map        avType = "M"
	avt_number     avType = "N"
	avt_number_set avType = "NS"
	avt_null       avType = "NULL"
	avt_string     avType = "S"
	avt_string_set avType = "SS"
)

func getAVType(field pgs.Field, fext *dynamopb.DynamoFieldOptions) avType {
	isArray := field.Type().ProtoLabel() == pgs.Repeated
	pt := field.Type().ProtoType()

	if isArray {
		if !fext.Type.Set {
			return avt_list
		}
		switch {
		case pt.IsInt() || pt == pgs.DoubleT || pt == pgs.FloatT:
			return avt_number_set
		case pt == pgs.StringT:
			return avt_string_set
		case pt == pgs.BytesT:
			return avt_byte_set
		case pt == pgs.EnumT:
			return avt_number_set
		}
	} else {
		switch {
		case pt.IsInt() || pt == pgs.DoubleT || pt == pgs.FloatT:
			return avt_number
		case pt == pgs.BoolT:
			return avt_bool
		case pt == pgs.StringT:
			return avt_string
		case pt == pgs.BytesT:
			return avt_bytes
		case pt == pgs.MessageT:
			return avt_map
		case pt == pgs.EnumT:
			return avt_number
		}
	}
	panic(fmt.Sprintf("getAVType: failed to determine dynamodb type: %T %+v", field, fext.Type))
}

func fieldByName(msg pgs.Message, name string) pgs.Field {
	for _, f := range msg.Fields() {
		if f.Name().LowerSnakeCase().String() == name {
			return f
		}
	}
	panic(fmt.Sprintf("Failed to find field %s on %s", name, msg.FullyQualifiedName()))
}

type namedKey struct {
	name     string
	prefix   bool
	constant string
	fields   []string
}

func getVersionField(msg pgs.Message) pgs.Field {
	fn := "updated_at"
	for _, f := range msg.Fields() {
		if f.Name().LowerSnakeCase().String() == fn {
			return f
		}
	}
	return nil
}

func (m *Module) applyVersionFuncs(msg pgs.Message, f *jen.File) error {
	structName := m.ctx.Name(msg)

	field := getVersionField(msg)
	if field == nil {
		// No version field, don't apply version func
		return nil
	}

	fn := field.Name().String()
	srcName := field.Name().UpperCamelCase().String()

	var stmts []jen.Code
	d := field.Descriptor().TypeName
	if d == nil {
		return errors.New(fmt.Sprintf("Failed to find field descriptor for %s on %s", fn, msg.FullyQualifiedName()))
	}
	if !strings.HasSuffix(*d, timestampType) {
		return errors.New(fmt.Sprintf("Field descriptor for %s on %s is not a timestamp", fn, msg.FullyQualifiedName()))
	}
	// 	err := p.UpdatedAt.CheckValid()
	//	if err != nil {
	//		return 0, err
	//	}
	//	t := p.UpdatedAt.AsTime()
	// return t.UnixNano(), nil
	stmts = append(stmts, jen.List(jen.Err()).Op(":=").Id("p").Dot("Get"+srcName).Call().Dot("CheckValid").Call())
	stmts = append(stmts, jen.If(jen.Err().Op("!=").Nil()).Block(jen.Return(jen.List(jen.Lit(0), jen.Err()))))
	stmts = append(stmts, jen.List(jen.Id("t")).Op(":=").Id("p").Dot("Get"+srcName).Call().Dot("AsTime").Call())
	stmts = append(stmts, jen.Return(jen.List(jen.Id("t").Dot("UnixNano").Call(), jen.Nil())))

	f.Func().Params(
		jen.Id("p").Op("*").Id(structName.String()),
	).Id("Version").Params().Parens(jen.List(jen.Int64(), jen.Error())).Block(stmts...).Line()

	return nil
}

func (m *Module) applyKeyFuncs(f *jen.File, in pgs.File) error {
	for _, msg := range in.AllMessages() {
		structName := m.ctx.Name(msg)
		mext := dynamopb.DynamoMessageOptions{}
		ok, err := msg.Extension(dynamopb.E_Msg, &mext)
		if err != nil {
			m.Logf("Parsing dynamo.msg.disabled failed: %s", err)
			m.Fail("code generation failed")
		}
		if ok && mext.Disabled {
			m.Logf("dynamo.msg disabled for %s", structName)
			continue
		}

		// Validate shard configuration for each key
		for _, key := range mext.Key {
			if err := validateShardConfig(msg, key); err != nil {
				m.Logf("Shard configuration validation failed: %s", err)
				m.Fail("code generation failed")
			}
		}

		var keys []namedKey
		// pk, sk, gsi1pk, gsi1sk
		for i, ck := range mext.Key {
			pkName := "PartitionKey"
			if i != 0 {
				pkName = fmt.Sprintf("Gsi%dPkKey", i)
			}

			if len(ck.PkFields) == 0 {
				m.Logf("Partition key %s must have at least one field", pkName)
				m.Fail("code generation failed")
			}

			keys = append(keys,
				namedKey{
					name:   pkName,
					fields: ck.PkFields,
					prefix: true,
				})

			if len(ck.SkFields) == 0 && ck.SkConst == "" {
				m.Logf("No sort key for key %s", pkName)
				continue
			}

			skName := "SortKey"
			if i != 0 {
				skName = fmt.Sprintf("Gsi%dSkKey", i)
			}

			keys = append(keys,
				namedKey{
					name:     skName,
					constant: ck.SkConst,
					fields:   ck.SkFields,
				})
		}

		if err := m.applyVersionFuncs(msg, f); err != nil {
			m.Logf("Generating version funcs failed: %s", err)
			m.Fail("code generation failed")
		}

		for _, key := range keys {
			var stmts []jen.Code
			if key.constant != "" {
				stmts = append(stmts,
					jen.Return(jen.Lit(key.constant)),
				)
			} else {
				stmts = append(stmts,
					jen.Op("var").Id("sb").Qual(stringsPkg, "Builder"),
				)

				// Check if this is a partition key with sharding enabled
				var keyIndex int = -1
				if key.prefix {
					if key.name == "PartitionKey" {
						keyIndex = 0
					} else {
						// Extract GSI index from name like "Gsi1PkKey"
						fmt.Sscanf(key.name, "Gsi%dPkKey", &keyIndex)
					}
				}

				if keyIndex >= 0 && keyIndex < len(mext.Key) && isShardingEnabled(mext.Key[keyIndex]) {
					// Use sharded key generation for this partition key
					ck := mext.Key[keyIndex]
					stmts = generateShardedKeyStringer(msg, stmts, key.prefix, ck.PkFields, ck.SkFields, ck.Shard, stringBuffer)
				} else {
					stmts = generateKeyStringer(msg, stmts, key.prefix, key.fields, stringBuffer)
				}

				stmts = append(stmts,
					jen.Return(jen.Id(stringBuffer).Dot("String").Call()),
				)
			}

			f.Func().Params(
				jen.Id("p").Op("*").Id(structName.String()),
			).Id(key.name).Params().List(jen.String()).Block(
				stmts...,
			).Line()

			var params []jen.Code
			d := jen.Dict{}
			for _, fn := range key.fields {
				field := fieldByName(msg, fn)
				typ := m.ctx.Type(field)
				params = append(params, jen.Id(field.Name().LowerCamelCase().String()).Id(typ.String()))
				d[jen.Id(field.Name().UpperCamelCase().String())] = jen.Id(field.Name().LowerCamelCase().String())
			}

			f.Func().Id(structName.String() + key.name).Params(params...).List(jen.String()).Block(
				jen.Return(jen.Call(jen.Op("&").Id(structName.String() + "_builder").Values(d)).Dot("Build").Call().Dot(key.name).Call()),
			).Line()
		}

		// Generate pagination functions for each sharded key
		for i, ck := range mext.Key {
			if !isShardingEnabled(ck) {
				continue
			}

			// Determine function name suffix based on key index
			var funcSuffix string
			if i == 0 {
				funcSuffix = ""
			} else {
				funcSuffix = fmt.Sprintf("Gsi%d", i)
			}

			// PartitionKeyWithShard(shard uint32) string
			var paginationStmts []jen.Code
			paginationStmts = append(paginationStmts,
				jen.Op("var").Id("sb").Qual(stringsPkg, "Builder"),
			)

			// Build prefix
			prefix := fmt.Sprintf("%s_%s", msg.Package().ProtoName().LowerSnakeCase().String(), msg.Name().LowerSnakeCase().String())
			paginationStmts = append(paginationStmts, jen.List(jen.Id("_"), jen.Id("_")).Op("=").Id("sb").Dot("WriteString").Call(
				jen.Lit(prefix+":"),
			))

			// Add PK fields
			first := true
			for _, fn := range ck.PkFields {
				field := fieldByName(msg, fn)
				pt := field.Type().ProtoType()
				srcName := field.Name().UpperCamelCase().String()
				srcFunc := jen.Id("p").Dot("Get" + srcName).Call()
				if !first {
					paginationStmts = append(paginationStmts, jen.List(jen.Id("_"), jen.Id("_")).Op("=").Id("sb").Dot("WriteString").Call(
						jen.Lit(":"),
					))
				}
				first = false
				switch {
				case pt == pgs.StringT:
					paginationStmts = append(paginationStmts, jen.List(jen.Id("_"), jen.Id("_")).Op("=").Id("sb").Dot("WriteString").Call(
						srcFunc,
					))
				case pt.IsNumeric() || pt == pgs.EnumT:
					fmtCall := numberFormatStatement(pt, srcFunc)
					paginationStmts = append(paginationStmts, jen.List(jen.Id("_"), jen.Id("_")).Op("=").Id("sb").Dot("WriteString").Call(
						fmtCall,
					))
				default:
					panic(fmt.Sprintf("Compound key: unsupported type: %s", pt.String()))
				}
			}

			// Add the provided shard at the end
			paginationStmts = append(paginationStmts, jen.List(jen.Id("_"), jen.Id("_")).Op("=").Id("sb").Dot("WriteString").Call(
				jen.Lit(":"),
			))
			paginationStmts = append(paginationStmts, jen.List(jen.Id("_"), jen.Id("_")).Op("=").Id("sb").Dot("WriteString").Call(
				jen.Qual(strconvPkg, "FormatUint").Call(jen.Uint64().Call(jen.Id("shard")), jen.Lit(10)),
			))

			paginationStmts = append(paginationStmts,
				jen.Return(jen.Id("sb").Dot("String").Call()),
			)

			f.Func().Params(
				jen.Id("p").Op("*").Id(structName.String()),
			).Id(funcSuffix + "PartitionKeyWithShard").Params(jen.Id("shard").Uint32()).List(jen.String()).Block(
				paginationStmts...,
			).Line()

			// PartitionKeysWithShard() []string - returns all possible sharded keys
			var allKeysStmts []jen.Code
			allKeysStmts = append(allKeysStmts,
				jen.Id("keys").Op(":=").Make(jen.Index().String(), jen.Lit(0), jen.Lit(ck.Shard.ShardCount)),
			)
			allKeysStmts = append(allKeysStmts,
				jen.For(jen.Id("i").Op(":=").Uint32().Call(jen.Lit(0)), jen.Id("i").Op("<").Lit(ck.Shard.ShardCount), jen.Id("i").Op("++")).Block(
					jen.Id("keys").Op("=").Append(jen.Id("keys"), jen.Id("p").Dot(funcSuffix+"PartitionKeyWithShard").Call(jen.Id("i"))),
				),
			)
			allKeysStmts = append(allKeysStmts,
				jen.Return(jen.Id("keys")),
			)

			f.Func().Params(
				jen.Id("p").Op("*").Id(structName.String()),
			).Id(funcSuffix + "PartitionKeysWithShard").Params().List(jen.Index().String()).Block(
				allKeysStmts...,
			).Line()
		}
	}
	return nil
}

func (m *Module) applyUtilityFuncs(f *jen.File, in pgs.File) error {
	for _, msg := range in.AllMessages() {
		structName := m.ctx.Name(msg)
		mext := dynamopb.DynamoMessageOptions{}
		ok, err := msg.Extension(dynamopb.E_Msg, &mext)
		if err != nil {
			m.Logf("Parsing dynamo.msg.disabled failed: %s", err)
			m.Fail("code generation failed")
		}
		if ok && mext.Disabled {
			m.Logf("dynamo.msg disabled for %s", structName)
			continue
		}

		// Generate shard utility functions for each sharded key
		for i, ck := range mext.Key {
			if !isShardingEnabled(ck) {
				continue
			}

			// Determine function name suffix based on key index
			var funcSuffix string
			if i == 0 {
				funcSuffix = ""
			} else {
				funcSuffix = fmt.Sprintf("Gsi%d", i)
			}

			// GetShardFromPartitionKey() (uint32, error) - extracts shard from actual PK
			var pkFuncName string
			if i == 0 {
				pkFuncName = "PartitionKey"
			} else {
				pkFuncName = fmt.Sprintf("Gsi%dPkKey", i)
			}

			f.Func().Params(
				jen.Id("p").Op("*").Id(structName.String()),
			).Id(fmt.Sprintf("Get%sShardFromPartitionKey", funcSuffix)).Params().Params(jen.Uint32(), jen.Error()).Block(
				jen.Id("pk").Op(":=").Id("p").Dot(pkFuncName).Call(),
				jen.Id("parts").Op(":=").Qual(stringsPkg, "Split").Call(jen.Id("pk"), jen.Lit(":")),
				jen.If(jen.Len(jen.Id("parts")).Op("==").Lit(0)).Block(
					jen.Return(jen.Lit(0), jen.Qual(fmtPkg, "Errorf").Call(jen.Lit("invalid key: empty"))),
				),
				jen.Id("lastPart").Op(":=").Id("parts").Index(jen.Len(jen.Id("parts")).Op("-").Lit(1)),
				jen.List(jen.Id("shard"), jen.Id("err")).Op(":=").Qual(strconvPkg, "ParseUint").Call(jen.Id("lastPart"), jen.Lit(10), jen.Lit(32)),
				jen.If(jen.Id("err").Op("!=").Nil()).Block(
					jen.Return(jen.Lit(0), jen.Qual(fmtPkg, "Errorf").Call(jen.Lit("failed to parse shard from key: %w"), jen.Id("err"))),
				),
				jen.Return(jen.Uint32().Call(jen.Id("shard")), jen.Nil()),
			).Line()

			// GetShardCount() uint32 - returns the hard-coded shard count
			f.Func().Params(
				jen.Id("p").Op("*").Id(structName.String()),
			).Id(fmt.Sprintf("Get%sShardCount", funcSuffix)).Params().Uint32().Block(
				jen.Return(jen.Lit(ck.Shard.ShardCount)),
			).Line()

			// Static function versions that don't need an instance
			f.Func().Id(fmt.Sprintf("%s%sShardCount", structName.String(), funcSuffix)).Params().Uint32().Block(
				jen.Return(jen.Lit(ck.Shard.ShardCount)),
			).Line()
		}
	}

	return nil
}

func generateKeyStringer(msg pgs.Message, stmts []jen.Code, addPrefix bool, fields []string, stringBuffer string) []jen.Code {
	stmts = append(stmts, jen.Id(stringBuffer).Dot("Reset").Call())
	sep := ":"
	prefix := ""
	if addPrefix {
		prefix = fmt.Sprintf("%s_%s", msg.Package().ProtoName().LowerSnakeCase().String(), msg.Name().LowerSnakeCase().String())
		stmts = append(stmts, jen.List(jen.Id("_"), jen.Id("_")).Op("=").Id(stringBuffer).Dot("WriteString").Call(
			jen.Lit(prefix+sep),
		))
	}

	first := true
	for _, fn := range fields {
		field := fieldByName(msg, fn)
		pt := field.Type().ProtoType()
		srcName := field.Name().UpperCamelCase().String()
		srcFunc := jen.Id("p").Dot("Get" + srcName).Call()
		if !first {
			stmts = append(stmts, jen.List(jen.Id("_"), jen.Id("_")).Op("=").Id(stringBuffer).Dot("WriteString").Call(
				jen.Lit(sep),
			))
		}
		first = false
		switch {
		case pt == pgs.StringT:
			stmts = append(stmts, jen.List(jen.Id("_"), jen.Id("_")).Op("=").Id(stringBuffer).Dot("WriteString").Call(
				srcFunc,
			))
		case pt.IsNumeric() || pt == pgs.EnumT:
			fmtCall := numberFormatStatement(pt, srcFunc)
			stmts = append(stmts, jen.List(jen.Id("_"), jen.Id("_")).Op("=").Id(stringBuffer).Dot("WriteString").Call(
				fmtCall,
			))
		default:
			panic(fmt.Sprintf("Compound key: unsupported type: %s", pt.String()))
		}
	}
	return stmts
}

// generateShardedKeyStringer generates a sharded partition key by calculating shard based on PK:SK
func generateShardedKeyStringer(msg pgs.Message, stmts []jen.Code, addPrefix bool, pkFields []string, skFields []string, shardConfig *dynamopb.ShardOptions, stringBuffer string) []jen.Code {
	stmts = append(stmts, jen.Id(stringBuffer).Dot("Reset").Call())
	sep := ":"
	prefix := ""
	if addPrefix {
		prefix = fmt.Sprintf("%s_%s", msg.Package().ProtoName().LowerSnakeCase().String(), msg.Name().LowerSnakeCase().String())
		stmts = append(stmts, jen.List(jen.Id("_"), jen.Id("_")).Op("=").Id(stringBuffer).Dot("WriteString").Call(
			jen.Lit(prefix+sep),
		))
	}

	// Add runtime validation for empty sort key fields
	if len(skFields) > 0 {
		for _, fn := range skFields {
			field := fieldByName(msg, fn)
			pt := field.Type().ProtoType()
			srcName := field.Name().UpperCamelCase().String()
			srcFunc := jen.Id("p").Dot("Get" + srcName).Call()

			switch {
			case pt == pgs.StringT:
				stmts = append(stmts,
					jen.If(jen.Len(srcFunc).Op("==").Lit(0)).Block(
						jen.Panic(jen.Qual(fmtPkg, "Sprintf").Call(
							jen.Lit("sharded key: sort key field '%s' cannot be empty"),
							jen.Lit(fn),
						)),
					),
				)
			case pt.IsNumeric() || pt == pgs.EnumT:
				// For numeric types, check if they are zero values (which might be valid)
				// We could add validation here if needed, but zero values are typically valid for numbers
			}
		}
	}

	// First, compute PK:SK for sharding
	stmts = append(stmts, jen.Op("var").Id("pkskBuilder").Qual(stringsPkg, "Builder"))

	// Build PK part
	first := true
	for _, fn := range pkFields {
		field := fieldByName(msg, fn)
		pt := field.Type().ProtoType()
		srcName := field.Name().UpperCamelCase().String()
		srcFunc := jen.Id("p").Dot("Get" + srcName).Call()
		if !first {
			stmts = append(stmts, jen.List(jen.Id("_"), jen.Id("_")).Op("=").Id("pkskBuilder").Dot("WriteString").Call(
				jen.Lit(sep),
			))
		}
		first = false
		switch {
		case pt == pgs.StringT:
			stmts = append(stmts, jen.List(jen.Id("_"), jen.Id("_")).Op("=").Id("pkskBuilder").Dot("WriteString").Call(
				srcFunc,
			))
		case pt.IsNumeric() || pt == pgs.EnumT:
			fmtCall := numberFormatStatement(pt, srcFunc)
			stmts = append(stmts, jen.List(jen.Id("_"), jen.Id("_")).Op("=").Id("pkskBuilder").Dot("WriteString").Call(
				fmtCall,
			))
		default:
			panic(fmt.Sprintf("Compound key: unsupported type: %s", pt.String()))
		}
	}

	// Add separator between PK and SK
	stmts = append(stmts, jen.List(jen.Id("_"), jen.Id("_")).Op("=").Id("pkskBuilder").Dot("WriteString").Call(
		jen.Lit(sep),
	))

	// Build SK part
	first = true
	for _, fn := range skFields {
		field := fieldByName(msg, fn)
		pt := field.Type().ProtoType()
		srcName := field.Name().UpperCamelCase().String()
		srcFunc := jen.Id("p").Dot("Get" + srcName).Call()
		if !first {
			stmts = append(stmts, jen.List(jen.Id("_"), jen.Id("_")).Op("=").Id("pkskBuilder").Dot("WriteString").Call(
				jen.Lit(sep),
			))
		}
		first = false
		switch {
		case pt == pgs.StringT:
			stmts = append(stmts, jen.List(jen.Id("_"), jen.Id("_")).Op("=").Id("pkskBuilder").Dot("WriteString").Call(
				srcFunc,
			))
		case pt.IsNumeric() || pt == pgs.EnumT:
			fmtCall := numberFormatStatement(pt, srcFunc)
			stmts = append(stmts, jen.List(jen.Id("_"), jen.Id("_")).Op("=").Id("pkskBuilder").Dot("WriteString").Call(
				fmtCall,
			))
		default:
			panic(fmt.Sprintf("Compound key: unsupported type: %s", pt.String()))
		}
	}

	// Calculate shard
	stmts = append(stmts, jen.Id("pkskStr").Op(":=").Id("pkskBuilder").Dot("String").Call())
	stmts = append(stmts, jen.Id("hashValue").Op(":=").Uint32().Call(jen.Qual(xxhashPkg, "Sum64String").Call(jen.Id("pkskStr"))))
	if shardConfig.ShardCount <= shardMinLimit || shardConfig.ShardCount > shardMaxLimit {
		panic(fmt.Sprintf("generateShardedKeyStringer: shard count must be between %d and %d", shardMinLimit, shardMaxLimit))
	}
	stmts = append(stmts, jen.Id("shardId").Op(":=").Id("hashValue").Op("%").Lit(shardConfig.ShardCount))

	// Now build the actual partition key with original PK fields first
	first = true
	for _, fn := range pkFields {
		field := fieldByName(msg, fn)
		pt := field.Type().ProtoType()
		srcName := field.Name().UpperCamelCase().String()
		srcFunc := jen.Id("p").Dot("Get" + srcName).Call()
		if !first {
			stmts = append(stmts, jen.List(jen.Id("_"), jen.Id("_")).Op("=").Id(stringBuffer).Dot("WriteString").Call(
				jen.Lit(sep),
			))
		}
		first = false
		switch {
		case pt == pgs.StringT:
			stmts = append(stmts, jen.List(jen.Id("_"), jen.Id("_")).Op("=").Id(stringBuffer).Dot("WriteString").Call(
				srcFunc,
			))
		case pt.IsNumeric() || pt == pgs.EnumT:
			fmtCall := numberFormatStatement(pt, srcFunc)
			stmts = append(stmts, jen.List(jen.Id("_"), jen.Id("_")).Op("=").Id(stringBuffer).Dot("WriteString").Call(
				fmtCall,
			))
		default:
			panic(fmt.Sprintf("Compound key: unsupported type: %s", pt.String()))
		}
	}

	// Add the shard at the end
	stmts = append(stmts, jen.List(jen.Id("_"), jen.Id("_")).Op("=").Id(stringBuffer).Dot("WriteString").Call(
		jen.Lit(sep),
	))
	stmts = append(stmts, jen.List(jen.Id("_"), jen.Id("_")).Op("=").Id(stringBuffer).Dot("WriteString").Call(
		jen.Qual(strconvPkg, "FormatUint").Call(jen.Uint64().Call(jen.Id("shardId")), jen.Lit(10)),
	))

	return stmts
}

const (
	valueField   = "value"
	deletedField = "deleted"
	typeField    = "typ"
)

func (m *Module) applyMarshal(f *jen.File, in pgs.File) error {
	for _, msg := range in.AllMessages() {
		mext := dynamopb.DynamoMessageOptions{}
		ok, err := msg.Extension(dynamopb.E_Msg, &mext)
		if err != nil {
			m.Logf("Parsing dynamo.msg.disabled failed: %s", err)
			m.Fail("code generation failed")
		}
		if ok && mext.Disabled {
			m.Logf("dynamo.msg disabled for %s", m.ctx.Name(msg))
			continue
		}

		// Validate shard configuration for each key
		for _, key := range mext.Key {
			if err := validateShardConfig(msg, key); err != nil {
				m.Logf("Shard configuration validation failed: %s", err)
				m.Fail("code generation failed")
			}
		}

		// https://pkg.go.dev/github.com/guregu/dynamo/v2#Marshaler
		// https://pkg.go.dev/github.com/guregu/dynamo/v2#ItemMarshaler
		err = m.applyMarshalMsgV2(f, msg, &mext)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *Module) applyUnmarshal(f *jen.File, in pgs.File) error {
	for _, msg := range in.AllMessages() {
		mext := dynamopb.DynamoMessageOptions{}
		ok, err := msg.Extension(dynamopb.E_Msg, &mext)
		if err != nil {
			m.Logf("Parsing dynamo.msg.disabled failed: %s", err)
			m.Fail("code generation failed")
		}
		if ok && mext.Disabled {
			m.Logf("dynamo.msg disabled for %s", m.ctx.Name(msg))
			continue
		}
		// https://pkg.go.dev/github.com/guregu/dynamo/v2#Unmarshaler
		// https://pkg.go.dev/github.com/guregu/dynamo/v2#ItemUnmarshaler
		err = m.applyUnmarshalMsgV2(f, msg)
		if err != nil {
			return err
		}
	}

	return nil
}

func numberFormatStatement(pt pgs.ProtoType, access *jen.Statement) *jen.Statement {
	var rv *jen.Statement
	switch pt {
	case pgs.DoubleT, pgs.FloatT:
		rv = jen.Qual(strconvPkg, "FormatFloat").Call(
			jen.Id("float64").Call(access),
			jen.LitByte('E'),
			jen.Lit(-1),
			jen.Lit(64),
		)
	case pgs.Int64T, pgs.SFixed64, pgs.SInt64, pgs.Int32T, pgs.SFixed32, pgs.SInt32, pgs.EnumT:
		rv = jen.Qual(strconvPkg, "FormatInt").Call(
			jen.Id("int64").Call(access),
			jen.Lit(10),
		)
	case pgs.UInt64T, pgs.Fixed64T, pgs.UInt32T, pgs.Fixed32T:
		rv = jen.Qual(strconvPkg, "FormatUint").Call(
			jen.Id("uint64").Call(access),
			jen.Lit(10),
		)
	}
	return rv
}

func numberParseStatement(pt pgs.ProtoType, access *jen.Statement) *jen.Statement {
	var rv *jen.Statement
	switch pt {
	case pgs.DoubleT, pgs.FloatT:
		rv = jen.Qual(strconvPkg, "ParseFloat").Call(
			jen.Qual(awsPkg, "StringValue").Call(access),
			jen.Lit(64),
		)
	case pgs.Int64T, pgs.SFixed64, pgs.SInt64, pgs.Int32T, pgs.SFixed32, pgs.SInt32:
		rv = jen.Qual(strconvPkg, "ParseInt").Call(
			jen.Qual(awsPkg, "StringValue").Call(access),
			jen.Lit(10),
			jen.Lit(64),
		)
	case pgs.UInt64T, pgs.Fixed64T, pgs.UInt32T, pgs.Fixed32T:
		rv = jen.Qual(strconvPkg, "ParseUint").Call(
			jen.Qual(awsPkg, "StringValue").Call(access),
			jen.Lit(10),
			jen.Lit(64),
		)
	}
	return rv
}

const (
	stringBuffer = "sb"
)

func (m *Module) applyMarshalMsgV2(f *jen.File, msg pgs.Message, mext *dynamopb.DynamoMessageOptions) error {
	structName := m.ctx.Name(msg)

	// https://pkg.go.dev/github.com/guregu/dynamo/v2#Marshaler
	// MarshalDynamo() (types.AttributeValue, error)
	f.Func().Params(
		jen.Id("p").Op("*").Id(structName.String()),
	).Id("MarshalDynamo").Params().List(jen.Params(jen.Qual(dynamoV2Pkg, "AttributeValue"), jen.Id("error"))).Block(
		jen.Return(jen.Id("p").Dot("MarshalDynamoDBAttributeValue").Call()),
	).Line()

	// https://pkg.go.dev/github.com/guregu/dynamo/v2#ItemMarshaler
	// MarshalDynamoItem() (map[string]types.AttributeValue, error)
	f.Func().Params(
		jen.Id("p").Op("*").Id(structName.String()),
	).Id("MarshalDynamoItem").Params().List(jen.Params(jen.Map(jen.String()).Qual(dynamoV2Pkg, "AttributeValue"), jen.Id("error"))).Block(
		jen.List(jen.Id("av"), jen.Id("err")).Op(":=").Id("p").Dot("MarshalDynamoDBAttributeValue").Call(),
		jen.If(jen.Id("err").Op("!=").Nil()).Block(
			jen.Return(jen.Nil(), jen.Id("err")),
		),
		jen.List(jen.Id("avm"), jen.Id("ok")).Op(":=").Id("av").Assert(jen.Op("*").Qual(dynamoV2Pkg, "AttributeValueMemberM")),
		jen.If(jen.Op("!").Id("ok")).Block(
			jen.Return(jen.Nil(), jen.Qual(fmtPkg, "Errorf").Call(jen.Lit("unable to marshal: expected type *types.AttributeValueMemberM, got %T"), jen.Id("av"))),
		),
		jen.Return(jen.Id("avm").Dot("Value"), jen.Nil()),
	).Line()

	var (
		stmts             []jen.Code
		refId             int
		needErr           bool
		needNullBoolTrue  bool
		needStringBuilder bool
	)
	d := jen.Dict{}

	computedKeys := make([]*dynamopb.Key, 0)
	if mext.Key != nil {
		computedKeys = append(computedKeys, mext.Key...)
	}

	for i, ck := range computedKeys {
		needStringBuilder = true

		pkName := "pk"
		if i != 0 {
			pkName = fmt.Sprintf("gsi%dpk", i)
		}
		skName := "sk"
		if i != 0 {
			skName = fmt.Sprintf("gsi%dsk", i)
		}
		refId++
		vname := fmt.Sprintf("v%d", refId)

		// Use sharded key generation for primary partition key if sharding is enabled
		if i == 0 && isShardingEnabled(ck) {
			stmts = generateShardedKeyStringer(msg, stmts, true, ck.PkFields, ck.SkFields, ck.Shard, stringBuffer)
		} else {
			stmts = generateKeyStringer(msg, stmts, true, ck.PkFields, stringBuffer)
		}
		stmts = append(stmts, jen.Id(vname).Op(":=").Op("&").Qual(dynamoV2Pkg, "AttributeValueMemberS").Values(jen.Dict{
			jen.Id("Value"): jen.Id(stringBuffer).Dot("String").Call(),
		}))
		d[jen.Lit(pkName)] = jen.Id(vname)
		refId++
		vname = fmt.Sprintf("v%d", refId)
		if ck.SkConst != "" {
			stmts = append(stmts, jen.Id(vname).Op(":=").Op("&").Qual(dynamoV2Pkg, "AttributeValueMemberS").Values(jen.Dict{
				jen.Id("Value"): jen.Lit(ck.SkConst),
			}))
			d[jen.Lit(skName)] = jen.Id(vname)
		} else {
			stmts = generateKeyStringer(msg, stmts, false, ck.SkFields, stringBuffer)
			stmts = append(stmts, jen.Id(vname).Op(":=").Op("&").Qual(dynamoV2Pkg, "AttributeValueMemberS").Values(jen.Dict{
				jen.Id("Value"): jen.Id(stringBuffer).Dot("String").Call(),
			}))
			d[jen.Lit(skName)] = jen.Id(vname)
		}
	}

	if getVersionField(msg) != nil {
		refId++
		vname := fmt.Sprintf("v%d", refId)
		// Version() (int64, error)
		stmts = append(stmts, jen.List(jen.Id(vname), jen.Id("err")).Op(":=").Id("p").Dot("Version").Call())
		stmts = append(stmts,
			jen.If(jen.Id("err").Op("!=").Nil()).Block(
				jen.Return(jen.Nil(), jen.Id("err")),
			),
		)
		d[jen.Lit("version")] = jen.Op("&").Qual(dynamoV2Pkg, "AttributeValueMemberN").Values(jen.Dict{
			jen.Id("Value"): jen.Call(jen.Qual(strconvPkg, "FormatInt").Call(jen.Id(vname), jen.Lit(10))),
		})
	}

	needErr = true
	refId++
	valVarName := fmt.Sprintf("v%d", refId)
	bufVName := fmt.Sprintf("v%dbuf", refId)

	stmts = append(stmts, jen.List(jen.Id(bufVName), jen.Id("err")).Op(":=").Qual(protozstdPkg, "Marshal").Call(jen.Id("p")))
	stmts = append(stmts,
		jen.If(jen.Id("err").Op("!=").Nil()).Block(
			jen.Return(jen.Nil(), jen.Id("err")),
		),
	)

	// Add compression logic for large messages
	stmts = append(stmts,
		jen.Id(valVarName).Op(":=").Op("&").Qual(dynamoV2Pkg, "AttributeValueMemberB").Values(jen.Dict{
			jen.Id("Value"): jen.Id(bufVName),
		}),
	)
	d[jen.Lit(valueField)] = jen.Id(valVarName)

	refId++
	typeName := fmt.Sprintf("%s.%s", msg.Package().ProtoName().String(), msg.Name())
	typeVarName := fmt.Sprintf("v%d", refId)
	stmts = append(stmts, jen.Id(typeVarName).Op(":=").Op("&").Qual(dynamoV2Pkg, "AttributeValueMemberS").Values(jen.Dict{
		jen.Id("Value"): jen.Lit(typeName),
	}))
	d[jen.Lit(typeField)] = jen.Id(typeVarName)

	for _, field := range msg.Fields() {
		fieldDescriptorName := field.Descriptor().GetTypeName()
		if strings.HasSuffix(fieldDescriptorName, timestampType) &&
			field.Name().LowerSnakeCase().String() == "deleted_at" {
			srcName := field.Name().UpperCamelCase().String()
			refId++
			vname := fmt.Sprintf("v%d", refId)
			stmts = append(stmts, jen.Id(vname).Op(":=").Op("&").Qual(dynamoV2Pkg, "AttributeValueMemberBOOL").Values(jen.Dict{
				jen.Id("Value"): jen.Id("p").Dot("Get" + srcName).Call().Dot("IsValid").Call(),
			}))
			d[jen.Lit(deletedField)] = jen.Id(vname)
		}
	}

	for _, field := range msg.Fields() {
		fext := dynamopb.DynamoFieldOptions{}
		ok, err := field.Extension(dynamopb.E_Field, &fext)
		if err != nil {
			m.Failf("Error: Parsing dynamo.field failed for '%s': %s", field.FullyQualifiedName(), err)
		}
		if !ok {
			m.Debugf("dynamo.field.expose: skipped %s (no extension)", field.FullyQualifiedName())
			continue
		}
		if !fext.Expose {
			m.Debugf("dynamo.field.expose: skipped %s (not exposed)", field.FullyQualifiedName())
			continue
		}

		if fext.Type == nil {
			fext.Type = &dynamopb.Types{}
		}
		pt := field.Type().ProtoType()

		srcName := field.Name().UpperCamelCase().String()
		refId++
		vname := fmt.Sprintf("v%d", refId)
		arrix := fmt.Sprintf("ix%d", refId)
		arrName := fmt.Sprintf("arr%d", refId)

		isArray := field.Type().ProtoLabel() == pgs.Repeated
		if fext.Type.Set && !isArray {
			m.Failf("Error: dynamo.field.set=true, but field is not repeated / array type: '%s'.IsRepeated=%v",
				field.FullyQualifiedName(), field.Type().IsRepeated())
		}

		avt := getAVType(field, &fext)
		fieldName := jen.Lit(field.Name().LowerSnakeCase().String())
		if fext.Name != "" {
			fieldName = jen.Lit(fext.Name)
		}

		switch avt {
		case avt_bytes:
			needNullBoolTrue = true
			srcFunc := jen.Id("p").Dot("Get" + srcName).Call()
			stmts = append(stmts,
				jen.If(jen.Len(jen.Id("p").Dot(field.Name().UpperCamelCase().String()).Op("!=").Lit(0)).Block(
					jen.Id(vname).Op(":=").Op("&").Qual(dynamoV2Pkg, "AttributeValueMemberB").Values(jen.Dict{jen.Id("Value"): srcFunc}),
				).Else().Block(
					jen.Id(vname).Op(":=").Op("&").Qual(dynamoV2Pkg, "AttributeValueMemberNULL").Values(jen.Dict{jen.Id("Value"): jen.Id("nullBoolTrue")}),
				)),
			)
			d[fieldName] = jen.Id(vname)
		case avt_bool:
			srcFunc := jen.Id("p").Dot("Get" + srcName).Call()
			d[fieldName] = jen.Op("&").Qual(dynamoV2Pkg, "AttributeValueMemberBOOL").Values(jen.Dict{jen.Id("Value"): srcFunc})
		case avt_list:
			srcFunc := jen.Id("p").Dot("Get" + srcName).Call()
			stmts = append(stmts,
				jen.Id(arrName).Op(":=").Make(
					jen.Op("[]").Qual(dynamoV2Pkg, "AttributeValue"),
					jen.Lit(0),
					jen.Len(srcFunc),
				),
			)

			switch {
			case pt.IsInt() || pt == pgs.DoubleT || pt == pgs.FloatT:
				fmtCall := numberFormatStatement(pt, jen.Id(arrix))
				stmts = append(stmts,
					jen.For(jen.List(jen.Id("_"), jen.Id(arrix)).Op(":=").Range().Id("p").Dot("Get"+srcName).Call()).Block(
						jen.Id(arrName).Op("=").Append(
							jen.Id(arrName),
							jen.Op("&").Qual(dynamoV2Pkg, "AttributeValueMemberN").Values(jen.Dict{
								jen.Id("Value"): jen.Call(
									fmtCall,
								),
							}),
						),
					),
				)
			case pt == pgs.StringT:
				stmts = append(stmts,
					jen.For(jen.List(jen.Id("_"), jen.Id(arrix)).Op(":=").Range().Id("p").Dot("Get"+srcName).Call()).Block(
						jen.Id(arrName).Op("=").Append(
							jen.Id(arrName),
							jen.Op("&").Qual(dynamoV2Pkg, "AttributeValueMemberS").Values(jen.Dict{
								jen.Id("Value"): jen.Id(arrix),
							}),
						),
					),
				)
			default:
				m.Failf("Error: dynamo.field '%s' is repeated, but the '%s' type is not supported", field.FullyQualifiedName(), pt.String())
			}
			d[fieldName] = jen.Op("&").Qual(dynamoV2Pkg, "AttributeValueMemberL").Values(jen.Dict{
				jen.Id("Value"): jen.Id(arrName),
			})
		case avt_map:
			fieldDescriptorName := field.Descriptor().TypeName
			if fieldDescriptorName == nil || (fieldDescriptorName != nil && !strings.HasSuffix(*fieldDescriptorName, timestampType)) {
				m.Failf("dynamo.field: not done: avt_map type: %s / %s", field.FullyQualifiedName(), *field.Descriptor().TypeName)
				panic("applyMarshalMsgV1 not done: avt_map for non-timestamps")
			}
			switch {
			case fext.Type.UnixMilli, fext.Type.UnixNano, fext.Type.UnixSecond:
				var access *jen.Statement
				switch {
				case fext.Type.UnixMilli:
					// .Round(time.Millisecond).UnixNano() / time.Millisecond
					access = jen.Id("p").Dot("Get" + srcName).Call().Dot("AsTime").Call().
						Dot("Round").Call(jen.Qual(timePkg, "Millisecond")).
						Dot("UnixNano").Call().Op("/").Int64().Call(jen.Qual(timePkg, "Millisecond"))
				case fext.Type.UnixNano:
					access = jen.Id("p").Dot("Get" + srcName).Call().Dot("AsTime").Call().Dot("UnixNano").Call()
				case fext.Type.UnixSecond:
					access = jen.Id("p").Dot("Get" + srcName).Call().Dot("AsTime").Call().
						Dot("Round").Call(jen.Qual(timePkg, "Second")).
						Dot("Unix").Call()
				}
				fmtCall := numberFormatStatement(pgs.Int64T, access)
				d[fieldName] = jen.Op("&").Qual(dynamoV2Pkg, "AttributeValueMemberN").Values(jen.Dict{
					jen.Id("Value"): jen.Call(fmtCall),
				})
			default:
				m.Failf("dynamo.field: not done: applyMarshalMsgV1 not done: timestamps must specify the conversion type %s", field.FullyQualifiedName())
				panic("applyMarshalMsgV1 not done: timestamps must specify the conversion type")
			}
		case avt_number:
			srcFunc := jen.Id("p").Dot("Get" + srcName).Call()
			fmtCall := numberFormatStatement(pt, srcFunc)
			d[fieldName] = jen.Op("&").Qual(dynamoV2Pkg, "AttributeValueMemberN").Values(jen.Dict{jen.Id("Value"): jen.Call(fmtCall)})
		case avt_null:
			// no-op
		case avt_string:
			needNullBoolTrue = true
			stmts = append(stmts, jen.Var().Id(vname).Qual(dynamoV2Pkg, "AttributeValue"))
			srcFunc := jen.Id("p").Dot("Get" + srcName).Call()
			stmts = append(stmts,
				jen.If(
					jen.Len(srcFunc).Op("!=").Lit(0)).Block(
					jen.Id(vname).Op("=").Op("&").Qual(dynamoV2Pkg, "AttributeValueMemberS").Values(jen.Dict{jen.Id("Value"): srcFunc}),
				).Else().Block(
					jen.Id(vname).Op("=").Op("&").Qual(dynamoV2Pkg, "AttributeValueMemberNULL").Values(jen.Dict{jen.Id("Value"): jen.Id("nullBoolTrue")}),
				),
			)
			d[fieldName] = jen.Id(vname)
		case avt_string_set, avt_number_set, avt_byte_set:
			needNullBoolTrue = true
			arrT := jen.Op("[]").Id("string")
			if avt == avt_byte_set {
				arrT = jen.Op("[][]").Id("byte")
			}
			stmts = append(stmts, jen.Id(arrName).Op(":=").Make(arrT, jen.Lit(0), jen.Len(jen.Id("p").Dot("Get"+srcName).Call())))
			setType := ""
			switch avt {
			case avt_number_set:
				setType = "NS"
				fmtCall := numberFormatStatement(pt, jen.Id(arrix))
				stmts = append(stmts,
					jen.For(jen.List(jen.Id("_"), jen.Id(arrix)).Op(":=").Range().Id("p").Dot("Get"+srcName).Call()).Block(
						jen.Id(arrName).Op("=").Append(jen.Id(arrName), jen.Call(fmtCall)),
					),
				)
			case avt_byte_set:
				setType = "BS"
				stmts = append(stmts,
					jen.For(jen.List(jen.Id("_"), jen.Id(arrix)).Op(":=").Range().Id("p").Dot("Get"+srcName).Call()).Block(
						jen.Id(arrName).Op("=").Append(jen.Id(arrName), jen.Id(arrix)),
					),
				)
			case avt_string_set:
				setType = "SS"
				stmts = append(stmts,
					jen.For(jen.List(jen.Id("_"), jen.Id(arrix)).Op(":=").Range().Id("p").Dot("Get"+srcName).Call()).Block(
						jen.Id(arrName).Op("=").Append(jen.Id(arrName), jen.Id(arrix)),
					),
				)
			default: // make lint happy

			}

			stmts = append(stmts,
				jen.If(jen.Len(jen.Id(arrName)).Op("!=").Lit(0)).Block(
					jen.Id(vname).Op(":=").Op("&").Qual(dynamoV2Pkg, fmt.Sprintf("AttributeValueMember%s", setType)).Values(jen.Dict{
						jen.Id("Value"): jen.Id(arrName),
					}),
				).Else().Block(
					jen.Id(vname).Op(":=").Op("&").Qual(dynamoV2Pkg, "AttributeValueMemberNULL").Values(jen.Dict{
						jen.Id("Value"): jen.Id("nullBoolTrue"),
					}),
				),
			)
			d[fieldName] = jen.Id(vname)
		}
	}

	if needNullBoolTrue {
		stmts = append([]jen.Code{
			jen.Id("nullBoolTrue").Op(":=").True(),
		}, stmts...)
	}

	if needErr {
		stmts = append([]jen.Code{
			jen.Op("var").Id("err").Id("error"),
		}, stmts...)
	}

	if needStringBuilder {
		stmts = append([]jen.Code{
			jen.Op("var").Id("sb").Qual(stringsPkg, "Builder"),
		}, stmts...)
	}

	stmts = append(stmts, jen.Var().Id("av").Qual(dynamoV2Pkg, "AttributeValue"))
	stmts = append(stmts, jen.Id("av").Op("=").Op("&").Qual(dynamoV2Pkg, "AttributeValueMemberM").Values(jen.Dict{
		jen.Id("Value"): jen.Map(jen.String()).Qual(dynamoV2Pkg, "AttributeValue").Values(d),
	}))

	stmts = append(stmts, jen.Return(jen.Id("av"), jen.Nil()))

	f.Func().Params(
		jen.Id("p").Op("*").Id(structName.String()),
	).Id("MarshalDynamoDBAttributeValue").Params().Call(jen.Qual(dynamoV2Pkg, "AttributeValue"), jen.Id("error")).Block(
		stmts...,
	).Line()

	return nil
}

func (m *Module) applyUnmarshalMsgV2(f *jen.File, msg pgs.Message) error {
	structName := m.ctx.Name(msg)

	var stmts []jen.Code

	typeName := fmt.Sprintf("%s.%s", msg.Package().ProtoName().String(), msg.Name())

	stmts = append(stmts,
		jen.List(jen.Id("m"), jen.Id("ok").Op(":=").Id("av").Assert(jen.Op("*").Qual(dynamoV2Pkg, "AttributeValueMemberM"))),
		jen.If(jen.Op("!").Id("ok")).Block(
			jen.Return(jen.Qual(fmtPkg, "Errorf").Call(jen.Lit("unable to unmarshal: expected type *types.AttributeValueMemberM, got %T"), jen.Id("av"))),
		),
	)

	stmts = append(stmts,
		jen.List(jen.Id(typeField), jen.Id("ok")).Op(":=").Id("m").Dot("Value").Index(jen.Lit(typeField)),
		jen.If(jen.Op("!").Id("ok")).Block(
			jen.Return(jen.Qual(fmtPkg, "Errorf").Call(
				jen.Lit("dynamo: "+typeField+" missing"),
			)),
		),
		jen.List(jen.Id("t"), jen.Id("ok")).Op(":=").Id(typeField).Assert(jen.Op("*").Qual(dynamoV2Pkg, "AttributeValueMemberS")),
		jen.If(jen.Op("!").Id("ok")).Block(
			jen.Return(jen.Qual(fmtPkg, "Errorf").Call(
				jen.Lit("unable to unmarshal: expected type *types.AttributeValueMemberS, got %T"), jen.Id(typeField),
			)),
		),
		jen.If(jen.Id("t").Dot("Value").Op("!=").Lit(typeName)).Block(
			jen.Return(jen.Qual(fmtPkg, "Errorf").Call(
				jen.Lit(fmt.Sprintf("dynamo: _type mismatch: %s expected, got: '%s'", typeName, "%s")),
				jen.Id(typeField),
			)),
		),
	)

	stmts = append(stmts,
		jen.List(jen.Id(valueField), jen.Id("ok")).Op(":=").Id("m").Dot("Value").Index(jen.Lit(valueField)),
		jen.If(jen.Op("!").Id("ok")).Block(
			jen.Return(jen.Qual(fmtPkg, "Errorf").Call(
				jen.Lit("dynamo: "+valueField+" missing"),
			)),
		),
		jen.List(jen.Id("v"), jen.Id("ok")).Op(":=").Id(valueField).Assert(jen.Op("*").Qual(dynamoV2Pkg, "AttributeValueMemberB")),
		jen.If(jen.Op("!").Id("ok")).Block(
			jen.Return(jen.Qual(fmtPkg, "Errorf").Call(
				jen.Lit("unable to unmarshal: expected type *types.AttributeValueMemberB, got %T"), jen.Id(valueField),
			)),
		),
		// Add decompression step for zstd compressed data
		jen.Var().Id("data").Index().Byte(),
		jen.Id("data").Op("=").Id("v").Dot("Value"),
		jen.Return(jen.Qual(protozstdPkg, "Unmarshal").Call(jen.Id("data"), jen.Id("p"))),
	)

	f.Func().Params(
		jen.Id("p").Op("*").Id(structName.String()),
	).Id("UnmarshalDynamoDBAttributeValue").Params(jen.Id("av").Qual(dynamoV2Pkg, "AttributeValue")).Id("error").Block(
		stmts...,
	).Line()

	// https://pkg.go.dev/github.com/guregu/dynamo/v2#Unmarshaler
	// UnmarshalDynamo(av types.AttributeValue) error
	f.Func().Params(
		jen.Id("p").Op("*").Id(structName.String()),
	).Id("UnmarshalDynamo").Params(jen.Id("av").Qual(dynamoV2Pkg, "AttributeValue")).Id("error").Block(
		jen.Return(jen.Id("p").Dot("UnmarshalDynamoDBAttributeValue").Call(jen.Id("av"))),
	).Line()

	// https://pkg.go.dev/github.com/guregu/dynamo/v2#ItemUnmarshaler
	// UnmarshalDynamoItem(av map[string]types.AttributeValue) error
	f.Func().Params(
		jen.Id("p").Op("*").Id(structName.String()),
	).Id("UnmarshalDynamoItem").Params(jen.Id("av").Map(jen.String()).Qual(dynamoV2Pkg, "AttributeValue")).Id("error").Block(
		jen.Return(jen.Id("p").Dot("UnmarshalDynamoDBAttributeValue").Call(
			jen.Op("&").Qual(dynamoV2Pkg, "AttributeValueMemberM").Values(jen.Dict{
				jen.Id("Value"): jen.Id("av"),
			}),
		)),
	).Line()

	return nil
}
